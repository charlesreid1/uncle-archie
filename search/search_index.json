{
    "docs": [
        {
            "location": "/",
            "text": "uncle-archie\n\u00b6\n\n\n\n\nUncle Archie\n is a home-brewed continuous integration server.\nIt handles pull request checks (build-test) and push-to-deploy \nfunctionality (build-test-deploy). It is written in Python\nand uses PyGithub.\n\n\nUncle Archie\n is intended to run behind an nginx reverse proxy\nso that SSL can be used. This requires that the server running \nUncle Archie be accessible via a domain name, and not just a bare \nIP address.\n\n\nDocumentation: \nhttps://pages.charlesreid1.com/uncle-archie\n\n\nSource code: \nhttps://git.charlesreid1.com/bots/uncle-archie\n\n\nSource code mirror: \nhttps://github.com/charlesreid1/uncle-archie\n\n\nTable of Contents\n\u00b6\n\n\n\n\nHow It Works\n\n\n\n\nDevOps:\n\n\n\n\n\n\nFlask Webhook Server\n\n\n\n\n\n\nNginx Web Server\n\n\n\n\n\n\nUncle Archie Startup Service\n\n\n\n\n\n\nPayloads and Hooks and Things:\n\n\n\n\n\n\nHow Payloads Are Processed\n\n\n\n\n\n\nCreating Payload Hooks",
            "title": "Index"
        },
        {
            "location": "/#uncle-archie",
            "text": "Uncle Archie  is a home-brewed continuous integration server.\nIt handles pull request checks (build-test) and push-to-deploy \nfunctionality (build-test-deploy). It is written in Python\nand uses PyGithub.  Uncle Archie  is intended to run behind an nginx reverse proxy\nso that SSL can be used. This requires that the server running \nUncle Archie be accessible via a domain name, and not just a bare \nIP address.  Documentation:  https://pages.charlesreid1.com/uncle-archie  Source code:  https://git.charlesreid1.com/bots/uncle-archie  Source code mirror:  https://github.com/charlesreid1/uncle-archie",
            "title": "uncle-archie"
        },
        {
            "location": "/#table-of-contents",
            "text": "How It Works   DevOps:    Flask Webhook Server    Nginx Web Server    Uncle Archie Startup Service    Payloads and Hooks and Things:    How Payloads Are Processed    Creating Payload Hooks",
            "title": "Table of Contents"
        },
        {
            "location": "/how/",
            "text": "How It Works\n\u00b6\n\n\nUncle Archie is a home-brewed continuous integration (CI) server.\n\n\nOn the front end, Uncle Archie receives webhooks from Github\nvia a Flask server. This webhook endpoint is installed in\nany repository that would potentially like to trigger CI \nbuilds with Uncle Archie.\n\n\nOn the back end, Uncle Archie passes each webhook to a set\nof user-defined Python functions that decide what to do.\nThey implement all of the logic - finding pull requests\nagainst master, identifying the head commit in a branch,\nupdating the status of a commit, etc etc.\n\n\nUncle Archie's flask server is simply a messenger - when\nevents happen in repositories, webhooks are sent to the\nflask server, which passes it along to each CI script.",
            "title": "How It Works"
        },
        {
            "location": "/how/#how-it-works",
            "text": "Uncle Archie is a home-brewed continuous integration (CI) server.  On the front end, Uncle Archie receives webhooks from Github\nvia a Flask server. This webhook endpoint is installed in\nany repository that would potentially like to trigger CI \nbuilds with Uncle Archie.  On the back end, Uncle Archie passes each webhook to a set\nof user-defined Python functions that decide what to do.\nThey implement all of the logic - finding pull requests\nagainst master, identifying the head commit in a branch,\nupdating the status of a commit, etc etc.  Uncle Archie's flask server is simply a messenger - when\nevents happen in repositories, webhooks are sent to the\nflask server, which passes it along to each CI script.",
            "title": "How It Works"
        },
        {
            "location": "/flask/",
            "text": "Flask Webhook Server\n\u00b6\n\n\nThe first component of Uncle Archie is the flask webhook server.\nThis is a server with one endpoint whose sole function is to \nreceive and process webhooks from any number of repositories.\n\n\nRoutes\n\u00b6\n\n\nThe Uncle Archie Flask server has one endpoint, \n/webhook\n. That is\nwhere all webhooks should be sent. If your Uncle Archie server is\nrunning at \narchie.mydomain.com\n, you should install webhooks with an endpoint\nof \nhttps://archie.mydomain.com/webhook\n (more on domain configuration\nand HTTPS on the \nNginx\n page).\n\n\nThe \n/webhook\n route is sent a JSON payload from Github. \n\n\nThe Flask server extracts meta-info (name of repo, type of event,\nname of branch) about the webhook event from the payload,\nthen passes all of this information to \nprocess_payload()\n\nin the \nprocess_payload.py\n file, which passes it on to \nuser-defined functions.\n\n\nThere are also \nwebhook examples\n\nin the Github documentation.\n\n\nInstalling Uncle Archie Webhooks in a Github Repo\n\u00b6\n\n\nTo install Uncle Archie in a Github repo you must be an admin\nor owner of that repo. Go to the repository's Settings page\nand pick Webhooks on the left side. Click the Add Webhook button.\n\n\nThis will ask you for the webhook format, the webhook URL endpoint,\nthe webhook secret, and which events you want to send.\n\n\nThe webhook format should be JSON - that's the drop-down menu.\n\n\nThe webhook URL endpoint is, as mentioned above, the URL of the\nUncle Archie server plus \n/webhook\n.\n\n\nThe webhook secret is set in \nconfig.json\n, loaded by the Flask\napplication. This is used to verify that incoming webhooks are,\nin fact, legitimate.\n\n\nFinally, the events that you want to send should be picked out\nfrom the menu of possible webhook events, affording the CI server\nmaximum flexibility.",
            "title": "Flask"
        },
        {
            "location": "/flask/#flask-webhook-server",
            "text": "The first component of Uncle Archie is the flask webhook server.\nThis is a server with one endpoint whose sole function is to \nreceive and process webhooks from any number of repositories.",
            "title": "Flask Webhook Server"
        },
        {
            "location": "/flask/#routes",
            "text": "The Uncle Archie Flask server has one endpoint,  /webhook . That is\nwhere all webhooks should be sent. If your Uncle Archie server is\nrunning at  archie.mydomain.com , you should install webhooks with an endpoint\nof  https://archie.mydomain.com/webhook  (more on domain configuration\nand HTTPS on the  Nginx  page).  The  /webhook  route is sent a JSON payload from Github.   The Flask server extracts meta-info (name of repo, type of event,\nname of branch) about the webhook event from the payload,\nthen passes all of this information to  process_payload() \nin the  process_payload.py  file, which passes it on to \nuser-defined functions.  There are also  webhook examples \nin the Github documentation.",
            "title": "Routes"
        },
        {
            "location": "/flask/#installing-uncle-archie-webhooks-in-a-github-repo",
            "text": "To install Uncle Archie in a Github repo you must be an admin\nor owner of that repo. Go to the repository's Settings page\nand pick Webhooks on the left side. Click the Add Webhook button.  This will ask you for the webhook format, the webhook URL endpoint,\nthe webhook secret, and which events you want to send.  The webhook format should be JSON - that's the drop-down menu.  The webhook URL endpoint is, as mentioned above, the URL of the\nUncle Archie server plus  /webhook .  The webhook secret is set in  config.json , loaded by the Flask\napplication. This is used to verify that incoming webhooks are,\nin fact, legitimate.  Finally, the events that you want to send should be picked out\nfrom the menu of possible webhook events, affording the CI server\nmaximum flexibility.",
            "title": "Installing Uncle Archie Webhooks in a Github Repo"
        },
        {
            "location": "/nginx/",
            "text": "Nginx Web Server\n\u00b6\n\n\nBackground\n\u00b6\n\n\nWhat Is Nginx?\n\u00b6\n\n\nnginx is a web server that can allow for a lot more flexibility\nin routing domain names and web traffic from the frontend to\nvarious backend servers.\n\n\nOne of the more useful functionalities in nginx is the ability to\nset up a reverse proxy.\n\n\nWhat Is A Reverse Proxy?\n\u00b6\n\n\nA proxy is defined as \nthe authority to represent someone else\n.\nTypically a proxy is set up to \"surround\" and \"wrap\" actions that\nthe user takes, and relay them to the \"outside world\" (i.e., the \nworld beyond the proxy).\n\n\nA reverse proxy means that instead of \"surrounding\" and \"wrapping\"\nthe client, a reverse proxy wraps the end server. That means that\nany requests for , say, \nhttps://archie.mydomain.com\n can be reverse \nproxied to the Uncle Archie Flask server at \nhttp://localhost:50005/\n.\n\n\nThe advantage of this is that Uncle Archie Flask is not accessible\nvia port 50005 to outside users. Every request must pass through nginx.\n\n\nFirst Steps: Installing Nginx\n\u00b6\n\n\nUsing your operating system's package manager is recommended:\n\n\napt-get install nginx\n\n\n\n\n\nOn Ubuntu, this will install configuration files to:\n\n\n/etc/nginx/\n\n\n\n\n\nand will make nginx a service that can be started/stopped with:\n\n\nsudo service nginx start\nsudo service nginx stop\n\n\n\n\n\nUncle Archie runs on port 50005 and is available at\n\nlocalhost:50005\n.\n\n\nNginx Standard Configuration\n\u00b6\n\n\nThe \"standard configuration\" for nginx is to use port 443 for\nHTTPS, port 80 for HTTP, and to automatically redirect HTTP\nrequests on port 80 to the more secure port 443.\n\n\nThe nginx configuration file below sets up nginx as a \nreverse proxy in front of Uncle Archie, and makes it available \nvia a subdomain like \narchie.mysite.com\n.\n\n\nHere is the nginx configuration file and the location\non disk where it should be using an aptitude-installed\nnginx:\n\n\n/etc/nginx/sites-available/archie.conf\n\n\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name archie.mydomain.com;\n    location / {\n        return 301 https://archie.mydomain.com$request_uri;\n    }\n}\n\nserver {\n    listen 443;\n    listen [::]:443;\n    server_name archie.mydomain.com;\n\n    ssl on;\n    ssl_certificate /etc/letsencrypt/live/archie.mydomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/archie.mydomain.com/privkey.pem;\n    include /etc/letsencrypt/options-ssl-nginx.conf;\n\n    client_max_body_size 100m;\n\n    gzip              on;\n    gzip_http_version 1.0;\n    gzip_proxied      any;\n    gzip_min_length   500;\n    gzip_disable      \"MSIE [1-6]\\.\";\n    gzip_types        text/plain text/xml text/css\n                      text/comma-separated-values\n                      text/javascript\n                      application/x-javascript\n                      application/atom+xml;\n\n    location /webhook {\n        # /webhook* anything takes user to port 5005, api\n        proxy_set_header   X-Real-IP  $remote_addr;\n        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header   Host $host;\n        proxy_pass http://127.0.0.1:5005/webhook;\n    }\n\n    ### location / {\n    ###     # Here, you can optionally redirect the user to \n    ###     # a landing page explaining the webhook server.\n    ###     #\n    ###     # ......or not.\n    ### }\n}\n\n\n\n\n\nThe configuration file (full contents given above) should be copied to\n(requires sudo access):\n\n\n/etc/nginx/sites-available/archie.conf\n\n\n\n\n\nThe site should then be enabled by linking this configuration\nfile to the \nsites-enabled\n folder:\n\n\nsudo ln -fs /etc/nginx/sites-available/archie.conf /etc/nginx/sites-enabled/\n\n\n\n\n\nNow nginx can be restarted:\n\n\nsudo service nginx restart",
            "title": "Nginx"
        },
        {
            "location": "/nginx/#nginx-web-server",
            "text": "",
            "title": "Nginx Web Server"
        },
        {
            "location": "/nginx/#background",
            "text": "",
            "title": "Background"
        },
        {
            "location": "/nginx/#what-is-nginx",
            "text": "nginx is a web server that can allow for a lot more flexibility\nin routing domain names and web traffic from the frontend to\nvarious backend servers.  One of the more useful functionalities in nginx is the ability to\nset up a reverse proxy.",
            "title": "What Is Nginx?"
        },
        {
            "location": "/nginx/#what-is-a-reverse-proxy",
            "text": "A proxy is defined as  the authority to represent someone else .\nTypically a proxy is set up to \"surround\" and \"wrap\" actions that\nthe user takes, and relay them to the \"outside world\" (i.e., the \nworld beyond the proxy).  A reverse proxy means that instead of \"surrounding\" and \"wrapping\"\nthe client, a reverse proxy wraps the end server. That means that\nany requests for , say,  https://archie.mydomain.com  can be reverse \nproxied to the Uncle Archie Flask server at  http://localhost:50005/ .  The advantage of this is that Uncle Archie Flask is not accessible\nvia port 50005 to outside users. Every request must pass through nginx.",
            "title": "What Is A Reverse Proxy?"
        },
        {
            "location": "/nginx/#first-steps-installing-nginx",
            "text": "Using your operating system's package manager is recommended:  apt-get install nginx  On Ubuntu, this will install configuration files to:  /etc/nginx/  and will make nginx a service that can be started/stopped with:  sudo service nginx start\nsudo service nginx stop  Uncle Archie runs on port 50005 and is available at localhost:50005 .",
            "title": "First Steps: Installing Nginx"
        },
        {
            "location": "/nginx/#nginx-standard-configuration",
            "text": "The \"standard configuration\" for nginx is to use port 443 for\nHTTPS, port 80 for HTTP, and to automatically redirect HTTP\nrequests on port 80 to the more secure port 443.  The nginx configuration file below sets up nginx as a \nreverse proxy in front of Uncle Archie, and makes it available \nvia a subdomain like  archie.mysite.com .  Here is the nginx configuration file and the location\non disk where it should be using an aptitude-installed\nnginx:  /etc/nginx/sites-available/archie.conf  server {\n    listen 80;\n    listen [::]:80;\n    server_name archie.mydomain.com;\n    location / {\n        return 301 https://archie.mydomain.com$request_uri;\n    }\n}\n\nserver {\n    listen 443;\n    listen [::]:443;\n    server_name archie.mydomain.com;\n\n    ssl on;\n    ssl_certificate /etc/letsencrypt/live/archie.mydomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/archie.mydomain.com/privkey.pem;\n    include /etc/letsencrypt/options-ssl-nginx.conf;\n\n    client_max_body_size 100m;\n\n    gzip              on;\n    gzip_http_version 1.0;\n    gzip_proxied      any;\n    gzip_min_length   500;\n    gzip_disable      \"MSIE [1-6]\\.\";\n    gzip_types        text/plain text/xml text/css\n                      text/comma-separated-values\n                      text/javascript\n                      application/x-javascript\n                      application/atom+xml;\n\n    location /webhook {\n        # /webhook* anything takes user to port 5005, api\n        proxy_set_header   X-Real-IP  $remote_addr;\n        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header   Host $host;\n        proxy_pass http://127.0.0.1:5005/webhook;\n    }\n\n    ### location / {\n    ###     # Here, you can optionally redirect the user to \n    ###     # a landing page explaining the webhook server.\n    ###     #\n    ###     # ......or not.\n    ### }\n}  The configuration file (full contents given above) should be copied to\n(requires sudo access):  /etc/nginx/sites-available/archie.conf  The site should then be enabled by linking this configuration\nfile to the  sites-enabled  folder:  sudo ln -fs /etc/nginx/sites-available/archie.conf /etc/nginx/sites-enabled/  Now nginx can be restarted:  sudo service nginx restart",
            "title": "Nginx Standard Configuration"
        },
        {
            "location": "/service/",
            "text": "Startup Service\n\u00b6\n\n\nSee \narchie.service\n\n\nNow install the service to \n/etc/systemd/system/archie.servce\n,\nand activate it:\n\n\nsudo systemctl enable archie.service\n\n\n\n\n\nNow you can start/stop the service with:\n\n\nsudo systemctl (start|stop) archie.service",
            "title": "Startup Service"
        },
        {
            "location": "/service/#startup-service",
            "text": "See  archie.service  Now install the service to  /etc/systemd/system/archie.servce ,\nand activate it:  sudo systemctl enable archie.service  Now you can start/stop the service with:  sudo systemctl (start|stop) archie.service",
            "title": "Startup Service"
        },
        {
            "location": "/payloads/",
            "text": "How Payloads Are Processed\n\u00b6\n\n\nUncle Archie runs a Flask server to receive webhooks.\nGithub sends webhooks in the form of JSON to the Flask\nserver when events occur on Github. The JSON file contains\nlots of information about the event - the who/what/where/when/how.\n\n\nThe JSON webhook is converted to a Python dictionary and is\npassed to the \nprocess_payload()\n function defined in \n\nprocess_payload.py\n.  The function takes three arguments:\nthe full payload, the meta-information (name of repo,\nname of branch, type of event), and the config dictionary\ncoming from \nconfig.json\n (this contains the Github API\nkey we need).\n\n\nHooks\n\u00b6\n\n\nEach incoming webhook payload is passed to a set of hook functions,\nwhich are Python functions that live in the \nhooks/\n folder.\nThese are imported and called by \nprocess_python.py\n.\n\n\nSee \nHooks\n for details about how the hooks work\nand how to define new ones.\n\n\nPayload Museum\n\u00b6\n\n\nTo see examples of payloads, visit the \nPayload Museum in the \nmuseum/\n directory\nof the repository.\n\n\nUncle Archie Configuration File\n\u00b6\n\n\nThe configuration file \nconfig.json\n contains \nboth\n Flask \nand\n \nbackend (hook-specific) configuration details.\n\n\nFor example, the secret key for the Flask server is a key that must\nbe embedded in the webhook for the webhook to be processed.\nThis is a flask-specific configuration detail. But the Github\nAPI key for the Github bot is also specified in the configuration\nfile, and that is information used by the hook functions.\n\n\nAPI keys are sensitive information so this file \nshould be kept secret (hence it is in \n.gitignore\n).\n\n\nThe config is loaded by the Flask application, since it contains\nflask-specific configuration details. The configuration is then\nhanded off to the process payload function, which passes it on \nto each hook function.\n\n\nIt is avialable via the variable \nconf\n.",
            "title": "Payload Processing"
        },
        {
            "location": "/payloads/#how-payloads-are-processed",
            "text": "Uncle Archie runs a Flask server to receive webhooks.\nGithub sends webhooks in the form of JSON to the Flask\nserver when events occur on Github. The JSON file contains\nlots of information about the event - the who/what/where/when/how.  The JSON webhook is converted to a Python dictionary and is\npassed to the  process_payload()  function defined in  process_payload.py .  The function takes three arguments:\nthe full payload, the meta-information (name of repo,\nname of branch, type of event), and the config dictionary\ncoming from  config.json  (this contains the Github API\nkey we need).",
            "title": "How Payloads Are Processed"
        },
        {
            "location": "/payloads/#hooks",
            "text": "Each incoming webhook payload is passed to a set of hook functions,\nwhich are Python functions that live in the  hooks/  folder.\nThese are imported and called by  process_python.py .  See  Hooks  for details about how the hooks work\nand how to define new ones.",
            "title": "Hooks"
        },
        {
            "location": "/payloads/#payload-museum",
            "text": "To see examples of payloads, visit the \nPayload Museum in the  museum/  directory\nof the repository.",
            "title": "Payload Museum"
        },
        {
            "location": "/payloads/#uncle-archie-configuration-file",
            "text": "The configuration file  config.json  contains  both  Flask  and  \nbackend (hook-specific) configuration details.  For example, the secret key for the Flask server is a key that must\nbe embedded in the webhook for the webhook to be processed.\nThis is a flask-specific configuration detail. But the Github\nAPI key for the Github bot is also specified in the configuration\nfile, and that is information used by the hook functions.  API keys are sensitive information so this file \nshould be kept secret (hence it is in  .gitignore ).  The config is loaded by the Flask application, since it contains\nflask-specific configuration details. The configuration is then\nhanded off to the process payload function, which passes it on \nto each hook function.  It is avialable via the variable  conf .",
            "title": "Uncle Archie Configuration File"
        },
        {
            "location": "/hooks/",
            "text": "Hooks\n\u00b6\n\n\nWhat Are Hooks\n\u00b6\n\n\nEach incoming webhook payload is passed to a set of hook functions,\nwhich are Python functions that live in the \nhooks/\n folder.\nThese are imported and called by \nprocess_python.py\n.\n\n\nHow Are Hook Functions Defined?\n\u00b6\n\n\nA hook is a Python file living in the \nhooks/\n directory.\nit should define one method \nprocess_payload()\n with the \nsame signature as the \nprocess_payload()\n method in \n\nprocess_payload.py\n.\n\n\nThe new hook function should also be imported in the file\n\nprocess_payload.py\n - this contains a series of calls to\nhook functions, and this occurs for each webhook received.\n\n\nHow To Define A New Hook Function?\n\u00b6\n\n\nTo make a new hook function:\n\n\n\n\nAdd a python file to \nhooks/\n\n\nDefine a method \nprocess_payload()\n (following \nprocess_payload.py\n)\n\n\nImport hook in \nprocess_payload.py\n\n\n\n\nAnd you're done.",
            "title": "Hook Functions"
        },
        {
            "location": "/hooks/#hooks",
            "text": "",
            "title": "Hooks"
        },
        {
            "location": "/hooks/#what-are-hooks",
            "text": "Each incoming webhook payload is passed to a set of hook functions,\nwhich are Python functions that live in the  hooks/  folder.\nThese are imported and called by  process_python.py .",
            "title": "What Are Hooks"
        },
        {
            "location": "/hooks/#how-are-hook-functions-defined",
            "text": "A hook is a Python file living in the  hooks/  directory.\nit should define one method  process_payload()  with the \nsame signature as the  process_payload()  method in  process_payload.py .  The new hook function should also be imported in the file process_payload.py  - this contains a series of calls to\nhook functions, and this occurs for each webhook received.",
            "title": "How Are Hook Functions Defined?"
        },
        {
            "location": "/hooks/#how-to-define-a-new-hook-function",
            "text": "To make a new hook function:   Add a python file to  hooks/  Define a method  process_payload()  (following  process_payload.py )  Import hook in  process_payload.py   And you're done.",
            "title": "How To Define A New Hook Function?"
        }
    ]
}